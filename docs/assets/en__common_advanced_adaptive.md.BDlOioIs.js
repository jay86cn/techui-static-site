import{_ as r,C as i,o as l,c as d,j as t,a,E as s,w as h,ah as c}from"./chunks/framework.PKn7PQPU.js";const E=JSON.parse('{"title":"Adaptive Panel","description":"","frontmatter":{},"headers":[],"relativePath":"en/_common/advanced/adaptive.md","filePath":"en/_common/advanced/adaptive.md"}'),p={name:"en/_common/advanced/adaptive.md"};function g(u,e,k,m,b,y){const o=i("AbsTag"),n=i("Primary");return l(),d("div",null,[e[1]||(e[1]=t("h1",{id:"adaptive-panel",tabindex:"-1"},[a("Adaptive Panel "),t("a",{class:"header-anchor",href:"#adaptive-panel","aria-label":'Permalink to "Adaptive Panel"'},"​")],-1)),s(o,{types:"wasm adv star 1st"}),e[2]||(e[2]=t("p",null,[t("strong",null,"TuiAdaptive"),a(" is one of the framework's core components, designed specifically for adaptive large-screen data visualization. Based on CSS3 "),t("code",null,"transform: scale"),a(', it allows your page to maintain the design aspect ratio on any screen resolution, achieving "Develop once, adapt to full screen".')],-1)),e[3]||(e[3]=t("p",null,[a("Furthermore, it addresses common pain points in large-screen development, such as "),t("strong",null,"GIS coordinate offsets"),a(", "),t("strong",null,"video wall ratio corrections"),a(", and "),t("strong",null,"asynchronous resource loading"),a(".")],-1)),s(n,null,{default:h(()=>[...e[0]||(e[0]=[a("TuiAdaptive is currently the only free and unlimited component among the 7 advanced components.",-1)])]),_:1}),e[4]||(e[4]=c(`<h2 id="basic-usage" tabindex="-1">Basic Usage <a class="header-anchor" href="#basic-usage" aria-label="Permalink to &quot;Basic Usage&quot;">​</a></h2><p>Use <code>TuiAdaptive</code> as the root element of the page to wrap all content.</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">TuiAdaptive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    :width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1920&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    adaptiveType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;extension&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">TuiAdaptive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="adaptive-modes" tabindex="-1">Adaptive Modes <a class="header-anchor" href="#adaptive-modes" aria-label="Permalink to &quot;Adaptive Modes&quot;">​</a></h2><p><code>TuiAdaptive</code> provides four core adaptive modes: <strong>Extension</strong>, <strong>Flexible</strong>, <strong>Fixed</strong>, and <strong>Stretch</strong>.</p><p>Configure via the <code>adaptiveType</code> prop.</p><h3 id="extension-mode" tabindex="-1">Extension Mode <a class="header-anchor" href="#extension-mode" aria-label="Permalink to &quot;Extension Mode&quot;">​</a></h3><p><code>adaptiveType=&quot;extension&quot;</code></p><p><strong>Scenario: Workbench / Portal Homepage / Mobile / Long Pages</strong></p><p>This is an adaptive mode based on <strong>fluid layout</strong>.</p><ul><li><strong>Logic:</strong> Width scales proportionally to fit the screen, <strong>height is unrestricted</strong> (allows extension and scrolling).</li><li><strong>Applicability:</strong></li><li>Suitable for pages with uncertain content height, such as workbenches in management backends, corporate portal homepages, or mobile H5 pages.</li><li><strong>Not recommended</strong> for visualization dashboards that aim to &quot;display all data on a single screen&quot;. Forcing a single screen&#39;s height to adapt to any range poses significant challenges for internal module layout adjustments.</li><li><strong>Exception:</strong> If your dashboard has too much data and the design explicitly allows using a <strong>scrollbar</strong> to show more data modules, this mode is the best choice.</li></ul><h3 id="flexible-mode-recommended-for-single-screen-data-apps" tabindex="-1">Flexible Mode (Recommended for Single-Screen Data Apps) <a class="header-anchor" href="#flexible-mode-recommended-for-single-screen-data-apps" aria-label="Permalink to &quot;Flexible Mode (Recommended for Single-Screen Data Apps)&quot;">​</a></h3><p><code>adaptiveType=&quot;flexible&quot;</code></p><p><strong>Scenario: PC Browser Environment / Presentations / Compatible with Non-Fullscreen Display</strong></p><p>This is the smartest and most commonly used adaptive mode (formerly called &quot;Advanced Mode&quot; in TechUI). It adapts intelligently between <strong>16:9 (Fullscreen)</strong> and <strong>approx. 2:1 (Non-fullscreen)</strong> ratios.</p><ul><li><p><strong>Solving Core Pain Points:</strong></p><ul><li>Perfectly solves the issue of displaying data screens on 1080P screens in <strong>non-fullscreen mode</strong>.</li><li>In non-fullscreen mode, the browser address bar, tabs, and system taskbar occupy about 100~150px of height, reducing the actual visible area to around <code>1920x930</code>.</li><li>Using <code>fixed</code> mode in this case would result in black bars, whereas <code>flexible</code> mode allows the content to automatically adjust and <strong>fill the entire visible browser window</strong>.</li></ul></li><li><p><strong>Logic:</strong></p><ul><li>Within the safe adaptation range (e.g., height between 930px ~ 1080px), content automatically fills the space without black bars.</li><li>Beyond the adaptation range (e.g., becoming extremely flat or tall), it falls back to the black-bar padding mode to ensure content is not severely distorted.</li></ul></li><li><p><strong>Default Size Parameters:</strong></p><ul><li><code>width</code>: No need to pass, defaults to <code>1920</code>. Can be passed if the data screen is not 1080p, e.g., pass <code>3840</code> for 4K screens.</li><li><code>height</code>: Dynamically calculated based on the ratio range, no need to pass value.</li></ul></li></ul><div class="warning custom-block"><p class="custom-block-title">Development Requirement</p><p>When using this mode, each sub-module (chart container, etc.) within the data screen needs to have some <strong>vertical flexibility</strong> (responsiveness) to adapt to slight stretching or compression in height.</p></div><h3 id="fixed-mode" tabindex="-1">Fixed Mode <a class="header-anchor" href="#fixed-mode" aria-label="Permalink to &quot;Fixed Mode&quot;">​</a></h3><p><code>adaptiveType=&quot;fixed&quot;</code></p><p><strong>Scenario: Video Wall (Splicing Screen) / Strict Ratio Single-Screen Visualization</strong></p><p>This is an adaptive mode based on a <strong>strict aspect ratio</strong>.</p><ul><li><strong>Logic:</strong> Strictly locks the aspect ratio of the design draft for scaling.</li><li><strong>Applicability:</strong><ul><li><strong>Video Walls:</strong> Designed for splicing screens with special ratios. For example, unconventional resolution combinations like 3x1 (5760x1080), 3x2 (5760x2160), 5x7, etc.</li><li><strong>Standard Dashboards:</strong> Also commonly used for standard 1920x1080 data screens.</li></ul></li></ul><div class="warning custom-block"><p class="custom-block-title">Note</p><p>When viewing on a standard 16:9 screen (e.g., 1080P/4K monitor), <strong>browser fullscreen (F11) must be enabled</strong>. If in non-fullscreen mode (with browser address bars, bookmark bars, system taskbars), <strong>black bars</strong> will appear on the top/bottom or left/right due to insufficient vertical visible area (less than 1080 pixels).</p></div><h3 id="stretch-mode" tabindex="-1">Stretch Mode <a class="header-anchor" href="#stretch-mode" aria-label="Permalink to &quot;Stretch Mode&quot;">​</a></h3><p><code>adaptiveType=&quot;stretch&quot;</code></p><p><strong>Scenario: Old Enterprise Video Wall Hardware Correction / Force Fill</strong></p><p>This is a mandatory <strong>physical deformation correction</strong> mode. It ignores the original ratio and forces the content to stretch along the X or Y axis to fill the container.</p><ul><li><p><strong>Logic:</strong> Forced filling, which changes the original view ratio (objects will appear flatter or thinner).</p></li><li><p><strong>General Use:</strong></p><ul><li>After a data screen is developed at 1080p, if it needs to fill the page in non-fullscreen mode without left/right black bars, this mode can be used for forced stretch correction.</li><li><em>Although theoretically supported, it is strongly discouraged for regular displays! Use Flexible mode instead.</em></li></ul></li><li><p><strong>Special Use - Old Video Wall Correction:</strong></p><ul><li><strong>Scenario:</strong> Facing some old splicing screens (e.g., 4x2 or 2x1), where the physical size is huge, but due to old matrix processors, the actual signal input resolution is still limited to 1920x1080.</li><li><strong>Problem:</strong> When a standard 1080P signal is projected onto a screen that is physically &quot;twice as wide&quot;, the image is horizontally stretched by the hardware by a factor of two, causing circles to become ellipses.</li><li><strong>Correction:</strong> With this mode, set <code>width=1920</code> during development. The component &quot;pre-compresses&quot; content that should be widescreen into a width of 1920 (looking squeezed on a PC). When the signal is projected onto the large screen and stretched by the hardware, it counteracts the deformation, simulating a normal high-definition widescreen visual effect.</li></ul></li></ul><h2 id="core-features" tabindex="-1">Core Features <a class="header-anchor" href="#core-features" aria-label="Permalink to &quot;Core Features&quot;">​</a></h2><h3 id="smart-loading" tabindex="-1">Smart Loading <a class="header-anchor" href="#smart-loading" aria-label="Permalink to &quot;Smart Loading&quot;">​</a></h3><p>Data screens often contain a large number of independent chart components. <code>TuiAdaptive</code> provides a counter-based overall loading mechanism to prevent the page from displaying components &quot;piece by piece&quot;.</p><p><strong>Working Principle:</strong> Set <code>portletCount</code> to the expected number of components. When sub-components integrated with <code>TuiLoaderPanel</code> (such as <code>TuiEcharts</code>) finish initializing, they automatically report their status. When the ready count meets the target, the Loading mask disappears automatically.</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">TuiAdaptive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :portletCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; ... &lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">TuiAdaptive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Without passing the <code>portletCount</code> parameter, you can also manually control the loading state via the <code>loading</code> parameter (Boolean).</p><h3 id="penetration-sync-container" tabindex="-1">Penetration Sync Container <a class="header-anchor" href="#penetration-sync-container" aria-label="Permalink to &quot;Penetration Sync Container&quot;">​</a></h3><p><strong>Solving GIS/Map Interaction Pain Points</strong></p><p>When using map components like Cesium or Leaflet, the parent container&#39;s <code>transform: scale</code> causes mouse click coordinates to drift. <code>TuiAdaptive</code> provides a special <code>#penetration</code> slot. The DOM inside this slot <strong>does not scale</strong>, but its size and position are completely synchronized with the main container, ensuring accurate interaction coordinates for GIS components.</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> #penetration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cesiumContainer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="view-control-mode" tabindex="-1">View Control Mode <a class="header-anchor" href="#view-control-mode" aria-label="Permalink to &quot;View Control Mode&quot;">​</a></h3><p><strong>Great for Meeting Presentations</strong></p><p>When <code>monitorRatio</code> is <code>true</code>, the component takes over the browser&#39;s zoom behavior (Ctrl + Scroll Wheel). The page is no longer just enlarged browser DOM elements, but becomes a canvas that can be <strong>Dragged (Pan)</strong> and <strong>Losslessly Zoomed</strong>, making it ideal for focusing on chart details during meetings.</p><h3 id="low-resolution-warning" tabindex="-1">Low Resolution Warning <a class="header-anchor" href="#low-resolution-warning" aria-label="Permalink to &quot;Low Resolution Warning&quot;">​</a></h3><p><strong>Ensuring Optimal Visual Experience</strong></p><p>TuiAdaptive has a built-in environment awareness feature. When the actual display resolution of the user&#39;s device is <strong>lower</strong> than the design resolution set in <code>TuiAdaptive</code> (<code>width</code> / <code>height</code>), a yellow warning bar (closable) automatically pops up at the bottom of the component.</p><ul><li><strong>Function:</strong> Reminds the user or presenter that the current screen resolution is insufficient (e.g., previewing a 1080P dashboard on a 1366x768 laptop), which may lead to loss of UI details or blurriness, and is not a program bug.</li><li><strong>Control:</strong> This warning is mandatory and cannot be disabled via props (although it is a normal DOM element and can be hidden via CSS, this is not recommended).</li></ul><h3 id="global-background-integration" tabindex="-1">Global Background Integration <a class="header-anchor" href="#global-background-integration" aria-label="Permalink to &quot;Global Background Integration&quot;">​</a></h3><p><strong>Smart Background Layer Management</strong></p><p>TechUI supports initializing a unified vector background (<code>tui-view-bg</code>) via global configuration. <code>TuiAdaptive</code> intelligently applies this background class to the appropriate DOM node based on the current configuration state:</p><ul><li><strong>Default:</strong> The background class is applied to the <strong>adaptive scaling container</strong>, scaling with the content.</li><li><strong>When Penetration Container is Enabled:</strong> If you use the <code>#penetration</code> slot, the background class is automatically transferred to the <strong>penetration sync container</strong>.</li><li><strong>Advantage:</strong> This ensures that the global background (such as starry sky, grid, etc.) is always at the bottom layer and does not suffer from accidental deformation or layer occlusion due to the scaling of the main container, making it very suitable for complex scenes overlaying GIS maps.</li></ul><p>For documentation on global backgrounds, please see the <a href="./../support/background.html">Infrastructure - Global Background</a> chapter.</p><h2 id="global-state-linkage" tabindex="-1">Global State Linkage <a class="header-anchor" href="#global-state-linkage" aria-label="Permalink to &quot;Global State Linkage&quot;">​</a></h2><p>The <strong>TuiAdaptive</strong> component is not just a simple layout container; it synchronizes its running state to the global service <code>$tState.adaptiveConfig</code> in real-time. You can implement complex interaction logic by injecting <code>$global</code> and listening to these states in business components.</p><h3 id="lifecycle-states-adptready-adptinited" tabindex="-1">Lifecycle States ($adptReady / $adptInited) <a class="header-anchor" href="#lifecycle-states-adptready-adptinited" aria-label="Permalink to &quot;Lifecycle States ($adptReady / $adptInited)&quot;">​</a></h3><ul><li><strong><code>$adptReady</code></strong>: Indicates that the adaptive configuration has loaded.</li><li><strong><code>$adptInited</code></strong>: Indicates that the TuiAdaptive component has finished mounting and DOM size calculation is complete.</li><li><strong>Linkage Behavior:</strong> When <code>$adptInited</code> becomes <code>true</code>, it means the width, height, and scale ratio of the dashboard container are determined. Sub-components dependent on parent container size (such as Maps, Canvas) should listen to this state to execute initialization.</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject, watch } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$adptInited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($adptInited, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (val) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Initialize map only after container dimensions are established</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="loading-counter-gportletcounter" tabindex="-1">Loading Counter ($gPortletCounter) <a class="header-anchor" href="#loading-counter-gportletcounter" aria-label="Permalink to &quot;Loading Counter ($gPortletCounter)&quot;">​</a></h3><ul><li><strong>Corresponding Prop:</strong> <code>portletCount</code></li><li><strong>Linkage Behavior:</strong><ul><li><strong>Target Setting:</strong> When you set <code>:portletCount=&quot;5&quot;</code> on the component, this value is set as the target threshold for completion.</li><li><strong>Auto Increment:</strong> Each <code>TuiLoaderPanel</code> (or chart component wrapping it) located inside TuiAdaptive will automatically call an internal mechanism to increment the global state <code>$gPortletCounter</code> by <strong>1</strong> upon initialization completion.</li><li><strong>Completion State:</strong> When the real-time counter state <code>$gPortletCounter</code> accumulates to equal the <code>portletCount</code> setting, TuiAdaptive&#39;s Loading mask automatically closes.</li><li><strong>Reset Counter:</strong> If multiple data screens share one TuiAdaptive component, when navigating between data screens, the overall loading process needs to be re-triggered. You <strong>must call the reset method</strong> <code>resetAdaptiveConfig()</code> to zero the counter; otherwise, the Loading mask will not show again because the counter has already met the target.</li><li>When the TuiAdaptive component is destroyed, the counter is also reset.</li></ul></li></ul><h3 id="resize-notification-aresizecounter" tabindex="-1">Resize Notification ($aResizeCounter) <a class="header-anchor" href="#resize-notification-aresizecounter" aria-label="Permalink to &quot;Resize Notification ($aResizeCounter)&quot;">​</a></h3><ul><li><strong>Linkage Behavior:</strong><ul><li>When the browser window size changes, or TuiAdaptive&#39;s adaptive mode changes, the component recalculates the scale ratio.</li><li>Upon completion, the value of <code>$aResizeCounter</code> automatically increments by <code>+1</code>.</li><li><strong>ECharts Linkage:</strong> The system&#39;s internal <code>TuiEcharts</code> component automatically watches this state. Once changed, it immediately executes <code>echartsInstance.resize()</code>, ensuring chart content is not blurred or distorted, without the need for developers to manually listen to <code>window.onresize</code>.</li></ul></li></ul><h3 id="view-control-tip-dragtip" tabindex="-1">View Control Tip (dragTip) <a class="header-anchor" href="#view-control-tip-dragtip" aria-label="Permalink to &quot;View Control Tip (dragTip)&quot;">​</a></h3><ul><li><strong>Corresponding Prop:</strong> <code>monitorRatio</code></li><li><strong>Linkage Behavior:</strong><ul><li>When View Control Mode is enabled (<code>monitorRatio=true</code>), the <code>adaptiveConfig.dragTip</code> state is activated.</li><li>This controls whether the &quot;Hold Ctrl to scroll/zoom / Drag to move&quot; operation tip is displayed on the interface.</li></ul></li></ul><h2 id="api-reference" tabindex="-1">API Reference <a class="header-anchor" href="#api-reference" aria-label="Permalink to &quot;API Reference&quot;">​</a></h2><h3 id="props" tabindex="-1">Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;Props&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Property Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><strong>width</strong></td><td>Number</td><td><code>1900</code></td><td>Design draft width.</td></tr><tr><td><strong>height</strong></td><td>Number</td><td><code>1060</code></td><td>Design draft height.</td></tr><tr><td><strong>adaptiveType</strong></td><td>String</td><td><code>&#39;extension&#39;</code></td><td>Adaptive mode. Options: <code>&#39;extension&#39;</code>, <code>&#39;flexible&#39;</code>, <code>&#39;fixed&#39;</code>, <code>&#39;stretch&#39;</code>, <code>&#39;disabled&#39;</code>.</td></tr><tr><td><strong>portletCount</strong></td><td>Number</td><td><code>0</code></td><td>Expected number of sub-components to load. Set to 0 to manually control loading.</td></tr><tr><td><strong>loading</strong></td><td>Boolean</td><td><code>true</code></td><td>(v-model) Loading state.</td></tr><tr><td><strong>monitorRatio</strong></td><td>Boolean</td><td><code>true</code></td><td>Whether to enable View Control Mode (take over browser zooming).</td></tr><tr><td><strong>adaptiveInterval</strong></td><td>Number</td><td><code>300</code></td><td>Debounce time for window change detection (ms).</td></tr><tr><td><strong>shadow</strong></td><td>Boolean</td><td><code>true</code></td><td>Whether to show container shadow.</td></tr><tr><td><strong>userSelect</strong></td><td>Boolean</td><td><code>false</code></td><td>Whether to allow text selection.</td></tr><tr><td><strong>tipMute</strong></td><td>Boolean</td><td><code>false</code></td><td>Whether to mute (hide) the low resolution warning bar.</td></tr><tr><td><strong>spinnerConfig</strong></td><td>Object</td><td>-</td><td>Loading style configuration.</td></tr></tbody></table><h3 id="slots" tabindex="-1">Slots <a class="header-anchor" href="#slots" aria-label="Permalink to &quot;Slots&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Slot Name</th><th>Description</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>Default slot. Content scales with the container.</td></tr><tr><td><strong>penetration</strong></td><td>Penetration slot. Content <strong>does not scale</strong>, dedicated for GIS/Map components.</td></tr></tbody></table><h3 id="events" tabindex="-1">Events <a class="header-anchor" href="#events" aria-label="Permalink to &quot;Events&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Event Name</th><th>Description</th></tr></thead><tbody><tr><td><strong>resizeStart</strong></td><td>Triggered when window size adjustment starts.</td></tr><tr><td><strong>resizeEnd</strong></td><td>Triggered when window size adjustment ends.</td></tr><tr><td><strong>update:loading</strong></td><td>Triggered when loading state changes.</td></tr></tbody></table>`,68))])}const v=r(p,[["render",g]]);export{E as __pageData,v as default};
