import{_ as a,C as s,o as n,c as o,j as e,a as r,E as l,ah as h}from"./chunks/framework.PKn7PQPU.js";const m=JSON.parse('{"title":"Notification Dispatcher","description":"","frontmatter":{},"headers":[],"relativePath":"en/tuiBase/attention/dispatcher.md","filePath":"en/tuiBase/attention/dispatcher.md"}'),d={name:"en/tuiBase/attention/dispatcher.md"};function c(p,t,g,u,k,f){const i=s("AbsTag");return n(),o("div",null,[t[0]||(t[0]=e("h1",{id:"notification-dispatcher",tabindex:"-1"},[r("Notification Dispatcher "),e("a",{class:"header-anchor",href:"#notification-dispatcher","aria-label":'Permalink to "Notification Dispatcher"'},"​")],-1)),l(i,{types:"1st"}),t[1]||(t[1]=h(`<p>The <strong>Dispatcher</strong> is the core &quot;traffic commander&quot; of the TechUI message notification system. It is invoked whenever any notification is triggered, managing the flow distribution for four notification types: <strong>Message</strong>, <strong>Notification</strong>, <strong>Toast</strong>, and <strong>Flash</strong>.</p><p>The primary responsibilities of the dispatcher include maintaining notification queues, calculating stacking positions, resolving priority conflicts (such as Flash interruptions), and preventing UI rendering chaos caused by a large volume of notifications triggered in a short period.</p><h2 id="core-dispatching-logic" tabindex="-1">Core Dispatching Logic <a class="header-anchor" href="#core-dispatching-logic" aria-label="Permalink to &quot;Core Dispatching Logic&quot;">​</a></h2><p>The dispatcher manages notifications across three dimensional channels:</p><h3 id="parallel-channel" tabindex="-1">Parallel Channel <a class="header-anchor" href="#parallel-channel" aria-label="Permalink to &quot;Parallel Channel&quot;">​</a></h3><p><strong>Applicable Components</strong>: <code>Message</code>, <code>Notification</code></p><ul><li><strong>Mechanism</strong>: Allows multiple instances to exist simultaneously.</li><li><strong>Layout</strong>: The dispatcher automatically calculates the vertical coordinates for each instance based on its height and a preset <code>offset</code> (spacing) to create a neat stacking effect.</li><li><strong>Grouping</strong>: When consecutive notifications with identical content and types are detected, the dispatcher merges them, updating the counter instead of adding new DOM nodes.</li></ul><h3 id="serial-channel-queue" tabindex="-1">Serial Channel (Queue) <a class="header-anchor" href="#serial-channel-queue" aria-label="Permalink to &quot;Serial Channel (Queue)&quot;">​</a></h3><p><strong>Applicable Components</strong>: <code>Toast</code></p><ul><li><strong>Mechanism</strong>: A strict single-instance queuing mechanism.</li><li><strong>Logic</strong>: Only one Toast can be displayed on the screen at a time. Subsequently triggered Toasts enter a memory queue. The dispatcher renders the next item in the queue only after the current Toast is destroyed (timer ends).</li></ul><h3 id="preemptive-channel-flash" tabindex="-1">Preemptive Channel (Flash) <a class="header-anchor" href="#preemptive-channel-flash" aria-label="Permalink to &quot;Preemptive Channel (Flash)&quot;">​</a></h3><p><strong>Applicable Components</strong>: <code>Flash</code></p><ul><li><strong>Mechanism</strong>: A high-priority exclusive mode.</li><li><strong>Logic</strong>: <ol><li>When a Flash is triggered, the dispatcher immediately <strong>pauses</strong> the current Toast queue.</li><li>The Flash is displayed with priority (accompanied by full-screen visual effects).</li><li>The dispatcher <strong>resumes</strong> the Toast queue only after the Flash queue is cleared (via manual closing or expiration).</li></ol></li><li><strong>Feature</strong>: Similar to an &quot;emergency vehicle,&quot; Flash possesses absolute right-of-way.</li></ul><h2 id="runtime-state" tabindex="-1">Runtime State <a class="header-anchor" href="#runtime-state" aria-label="Permalink to &quot;Runtime State&quot;">​</a></h2><p>TechUI exposes the real-time operational state of the dispatcher through the <code>$aDispatcher</code> object. This is typically used for debugging or developing custom state monitoring panels.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$aDispatcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Access current state</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($aDispatcher.queue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="read-only-properties" tabindex="-1">Read-only Properties <a class="header-anchor" href="#read-only-properties" aria-label="Permalink to &quot;Read-only Properties&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><strong>currentChannel</strong></td><td>String</td><td>The name of the currently active channel. Possible values: <code>null</code> (idle), <code>&#39;parallel&#39;</code>, <code>&#39;serial&#39;</code>, <code>&#39;flash&#39;</code>.</td></tr><tr><td><strong>queue</strong></td><td>Array</td><td>The queue of messages waiting to be displayed, containing configurations for all Toast or Flash instances not yet rendered.</td></tr></tbody></table><h2 id="global-configuration" tabindex="-1">Global Configuration <a class="header-anchor" href="#global-configuration" aria-label="Permalink to &quot;Global Configuration&quot;">​</a></h2><p>The dispatcher&#39;s behavioral configuration is located in <code>$attentionConfig.dispatcher</code>. These settings are <strong>reactive</strong> and immediately affect subsequent notification behavior upon modification.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$attentionConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Modify stacking offset</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$attentionConfig.value.dispatcher.offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="configuration-items" tabindex="-1">Configuration Items <a class="header-anchor" href="#configuration-items" aria-label="Permalink to &quot;Configuration Items&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><strong>visible</strong></td><td>Boolean</td><td><code>true</code></td><td>Whether the dispatcher is enabled. Setting this to <code>false</code> prevents all notifications from appearing.</td></tr><tr><td><strong>debug</strong></td><td>Boolean</td><td><code>false</code></td><td>Whether to enable the built-in visual debug panel (displays queue info in the bottom-right corner).</td></tr><tr><td><strong>offset</strong></td><td>Number</td><td><code>40</code></td><td>The vertical spacing (px) for stacking in the Parallel channel (Message/Notify).</td></tr><tr><td><strong>position</strong></td><td>String</td><td><code>&#39;bottom-right&#39;</code></td><td>The position of the debug panel on the screen.</td></tr></tbody></table><h2 id="internal-api" tabindex="-1">Internal API <a class="header-anchor" href="#internal-api" aria-label="Permalink to &quot;Internal API&quot;">​</a></h2><p>While developers usually call specific methods like <code>$tMessage</code>, understanding the underlying APIs helps clarify how the system works.</p><h3 id="tattentiondispatcher-options" tabindex="-1">$tAttentionDispatcher(options) <a class="header-anchor" href="#tattentiondispatcher-options" aria-label="Permalink to &quot;$tAttentionDispatcher(options)&quot;">​</a></h3><p>This is the low-level entry point for all notification components. When you call <code>$tMessage</code>, your parameters are standardized and passed to this method.</p><ul><li><strong>Function</strong>: Pushes the notification request into the dispatch pipeline.</li><li><strong>Parameters</strong>: Accepts a configuration object containing component type, content, priority, etc.</li></ul><h3 id="tattentiondispatcherclose" tabindex="-1">$tAttentionDispatcherClose() <a class="header-anchor" href="#tattentiondispatcherclose" aria-label="Permalink to &quot;$tAttentionDispatcherClose()&quot;">​</a></h3><ul><li><strong>Function</strong>: Forcefully clears all queues in the dispatcher and destroys all currently displayed notification instances.</li><li><strong>Scenario</strong>: Typically called during route transitions or user logout to ensure a clean interface.</li></ul>`,30))])}const b=a(d,[["render",c]]);export{m as __pageData,b as default};
