import{_ as e,C as i,c as l,o as n,j as s,G as o,aj as h,a as r}from"./chunks/framework.DPdjieCD.js";const f=JSON.parse('{"title":"通知调度器","description":"","frontmatter":{},"headers":[],"relativePath":"cn/tuiBase/attention/dispatcher.md","filePath":"cn/tuiBase/attention/dispatcher.md"}'),d={name:"cn/tuiBase/attention/dispatcher.md"};function p(g,t,c,k,y,E){const a=i("AbsTag");return n(),l("div",null,[t[0]||(t[0]=s("h1",{id:"通知调度器",tabindex:"-1"},[r("通知调度器 "),s("a",{class:"header-anchor",href:"#通知调度器","aria-label":'Permalink to "通知调度器"'},"​")],-1)),o(a,{types:"1st"}),t[1]||(t[1]=h(`<p><strong>调度器 (Dispatcher)</strong> 是 TechUI 消息通知系统的核心“交通指挥官”。在触发任意通知的时候它会被调用，它接管了 Message、Notification、Toast 和 Flash 四种通知类型的流量分发。</p><p>调度器的主要职责是维护通知队列、计算堆叠位置、处理优先级冲突（如 Flash 插队），并防止短时间内触发大量通知导致界面渲染混乱。</p><h2 id="核心调度逻辑" tabindex="-1">核心调度逻辑 <a class="header-anchor" href="#核心调度逻辑" aria-label="Permalink to &quot;核心调度逻辑&quot;">​</a></h2><p>调度器将通知分为三个维度的通道进行管理：</p><h3 id="并行通道-parallel" tabindex="-1">并行通道 (Parallel) <a class="header-anchor" href="#并行通道-parallel" aria-label="Permalink to &quot;并行通道 (Parallel)&quot;">​</a></h3><p><strong>适用组件</strong>: <code>Message</code>, <code>Notification</code></p><ul><li><strong>机制</strong>: 允许同时存在多个实例。</li><li><strong>布局</strong>: 调度器会根据实例的高度和预设的 <code>offset</code>（间距），自动计算每个实例的垂直坐标，形成整齐的堆叠效果。</li><li><strong>分组</strong>: 当检测到连续触发的通知具有相同的内容和类型时，调度器会将其合并，仅更新计数器，不再新增 DOM 节点。</li></ul><h3 id="串行通道-serial-queue" tabindex="-1">串行通道 (Serial / Queue) <a class="header-anchor" href="#串行通道-serial-queue" aria-label="Permalink to &quot;串行通道 (Serial / Queue)&quot;">​</a></h3><p><strong>适用组件</strong>: <code>Toast</code></p><ul><li><strong>机制</strong>: 严格的单实例排队机制。</li><li><strong>逻辑</strong>: 屏幕上同一时间只能显示一个 Toast。后续触发的 Toast 会进入内存队列等待。只有当前一个 Toast 销毁（倒计时结束）后，调度器才会从队列中取出下一个并渲染。</li></ul><h3 id="强占通道-preemptive-flash" tabindex="-1">强占通道 (Preemptive / Flash) <a class="header-anchor" href="#强占通道-preemptive-flash" aria-label="Permalink to &quot;强占通道 (Preemptive / Flash)&quot;">​</a></h3><p><strong>适用组件</strong>: <code>Flash</code></p><ul><li><strong>机制</strong>: 最高优先级的独占模式。</li><li><strong>逻辑</strong>: <ol><li>当 Flash 触发时，调度器会立即<strong>暂停</strong>当前的 Toast 队列。</li><li>Flash 优先展示（伴随全屏视觉效果）。</li><li>Flash 队列清空（手动关闭或结束）后，调度器才会<strong>恢复</strong> Toast 队列的执行。</li></ol></li><li><strong>特性</strong>: 类似于“警车开道”，Flash 拥有绝对的路权。</li></ul><h2 id="运行时状态" tabindex="-1">运行时状态 <a class="header-anchor" href="#运行时状态" aria-label="Permalink to &quot;运行时状态&quot;">​</a></h2><p>TechUI 通过 <code>$aDispatcher</code> 对象暴露了调度器的实时运行状态。这通常用于调试或开发自定义的状态监控面板。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$aDispatcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问当前状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($aDispatcher.queue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="只读属性" tabindex="-1">只读属性 <a class="header-anchor" href="#只读属性" aria-label="Permalink to &quot;只读属性&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">属性名</th><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>currentChannel</strong></td><td style="text-align:left;">String</td><td style="text-align:left;">当前正在活跃的通道名称。可能的值：<code>null</code> (空闲), <code>&#39;parallel&#39;</code>, <code>&#39;serial&#39;</code>, <code>&#39;flash&#39;</code>。</td></tr><tr><td style="text-align:left;"><strong>queue</strong></td><td style="text-align:left;">Array</td><td style="text-align:left;">当前等待展示的消息队列。包含了所有尚未渲染的 Toast 或 Flash 实例配置。</td></tr></tbody></table><h2 id="全局配置" tabindex="-1">全局配置 <a class="header-anchor" href="#全局配置" aria-label="Permalink to &quot;全局配置&quot;">​</a></h2><p>调度器的行为配置位于 <code>$attentionConfig.dispatcher</code> 中。这些配置是<strong>响应式</strong>的，修改后会立即影响后续的通知行为。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$attentionConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改堆叠间距</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$attentionConfig.value.dispatcher.offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="配置项" tabindex="-1">配置项 <a class="header-anchor" href="#配置项" aria-label="Permalink to &quot;配置项&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">属性名</th><th style="text-align:left;">类型</th><th style="text-align:left;">默认值</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>visible</strong></td><td style="text-align:left;">Boolean</td><td style="text-align:left;"><code>true</code></td><td style="text-align:left;">是否启用调度器。设为 <code>false</code> 将阻止所有通知显示。</td></tr><tr><td style="text-align:left;"><strong>debug</strong></td><td style="text-align:left;">Boolean</td><td style="text-align:left;"><code>false</code></td><td style="text-align:left;">是否开启内置的可视化调试面板（在屏幕右下角显示队列信息）。</td></tr><tr><td style="text-align:left;"><strong>offset</strong></td><td style="text-align:left;">Number</td><td style="text-align:left;"><code>40</code></td><td style="text-align:left;">并行通道（Message/Notify）堆叠时的垂直间距 (px)。</td></tr><tr><td style="text-align:left;"><strong>position</strong></td><td style="text-align:left;">String</td><td style="text-align:left;"><code>&#39;bottom-right&#39;</code></td><td style="text-align:left;">调试面板在屏幕上的位置。</td></tr></tbody></table><h2 id="内部-api" tabindex="-1">内部 API <a class="header-anchor" href="#内部-api" aria-label="Permalink to &quot;内部 API&quot;">​</a></h2><p>虽然开发者通常直接调用 <code>$tMessage</code> 等具体方法，但了解底层 API 有助于理解其工作原理。</p><h3 id="tattentiondispatcher-options" tabindex="-1">$tAttentionDispatcher(options) <a class="header-anchor" href="#tattentiondispatcher-options" aria-label="Permalink to &quot;$tAttentionDispatcher(options)&quot;">​</a></h3><p>这是所有通知组件的底层入口。当您调用 <code>$tMessage</code> 时，实际上是将参数标准化后传递给了此方法。</p><ul><li><strong>功能</strong>: 将通知请求推入调度管道。</li><li><strong>参数</strong>: 接收包含组件类型、内容、优先级等信息的配置对象。</li></ul><h3 id="tattentiondispatcherclose" tabindex="-1">$tAttentionDispatcherClose() <a class="header-anchor" href="#tattentiondispatcherclose" aria-label="Permalink to &quot;$tAttentionDispatcherClose()&quot;">​</a></h3><ul><li><strong>功能</strong>: 强制清空调度器中的所有队列，并销毁当前所有显示的通知实例。</li><li><strong>场景</strong>: 通常在路由切换或用户注销时调用，以确保界面干净。</li></ul>`,30))])}const b=e(d,[["render",p]]);export{f as __pageData,b as default};
