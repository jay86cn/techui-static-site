import{_ as i,c as a,o as n,aj as t}from"./chunks/framework.DPdjieCD.js";const E=JSON.parse('{"title":"动态路由","description":"","frontmatter":{},"headers":[],"relativePath":"cn/_common/admin/dynamicRouter.md","filePath":"cn/_common/admin/dynamicRouter.md"}'),e={name:"cn/_common/admin/dynamicRouter.md"};function l(h,s,k,p,r,o){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="动态路由" tabindex="-1">动态路由 <a class="header-anchor" href="#动态路由" aria-label="Permalink to &quot;动态路由&quot;">​</a></h1><p>TechUI 的动态路由机制是后台管理系统的核心。它采用 <strong>后端控制策略</strong>，即路由表并非在前端硬编码，而是根据当前登录用户的权限，由后端返回菜单数据，前端再结合本地的组件注册表，动态生成 Vue Router 路由配置。</p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><ol><li><strong>组件注册</strong>：前端维护一份 <code>register.js</code>，将路由标识（字符串）映射到真实的 Vue 组件文件。</li><li><strong>获取菜单</strong>：用户登录后，从后端或本地数据库获取菜单树数据。</li><li><strong>路由匹配</strong>：通过 <code>routerPackag</code> 函数，将菜单数据中的 <code>label</code> 与组件注册表匹配。</li><li><strong>动态挂载</strong>：使用 <code>router.addRoute</code> 将匹配成功的组件挂载到名为 <code>layout</code> 的父路由下。</li><li><strong>全局拦截</strong>：在 <code>router.beforeEach</code> 中处理页面刷新、鉴权、Tab 页签添加等逻辑。</li></ol><h2 id="核心流程解析" tabindex="-1">核心流程解析 <a class="header-anchor" href="#核心流程解析" aria-label="Permalink to &quot;核心流程解析&quot;">​</a></h2><p>动态路由的逻辑主要集中在全局 Provider 组件中，仅当 <code>isActAdminFeatures</code> 为真时激活。</p><h3 id="数据持久化与同步" tabindex="-1">数据持久化与同步 <a class="header-anchor" href="#数据持久化与同步" aria-label="Permalink to &quot;数据持久化与同步&quot;">​</a></h3><p>为了防止页面刷新导致 Vuex/Pinia 状态丢失，TechUI 实现了双重持久化机制：</p><ul><li><strong>用户信息 (UserInfo)</strong>： 通过 <code>watch</code> 监听 <code>$tState.ADMIN.userInfo</code>。一旦变化，使用 <code>tStoreCrypto</code>（加密存储）同步到 Session/Local Storage。同时，如果发现 Token 或 ID 丢失，会自动触发登出。</li><li><strong>菜单数据 (Menu)</strong>： 通过 <code>watch</code> 监听 <code>$tState.ADMIN.menu</code>。一旦获取到菜单数据，会将其写入 <strong>IndexedDB</strong> (<code>TuiDB</code>)。这确保了即使用户刷新页面，也能从本地数据库快速恢复庞大的菜单结构，而无需再次请求后端。</li></ul><h3 id="路由组装-routerpackag" tabindex="-1">路由组装 (routerPackag) <a class="header-anchor" href="#路由组装-routerpackag" aria-label="Permalink to &quot;路由组装 (routerPackag)&quot;">​</a></h3><p><code>routerPackag</code> 是将业务数据转换为路由配置的核心函数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 伪代码逻辑演示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> routerPackag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">routerData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">routerData.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1. 解构后端数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { label, icon, title, keepAlive, ... } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> routerData[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2. 在注册表中查找组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> comp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $tState.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADMIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.componentRegister[label];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3. 如果不是父节点且组件存在</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isParent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> comp){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 4. 动态添加路由到 &#39;layout&#39; 父节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;layout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> label, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认路径为 /label</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: label,       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由名称</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        component: comp,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对应的 Vue 组件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        meta: { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注入 meta 信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>关键点：</strong></p><ul><li>所有动态路由都是 <code>layout</code> 路由的子路由。这意味着它们都会渲染在 <code>TuiAdminLayout</code> 的 <code>&lt;router-view&gt;</code> 中。</li><li>路由的 <code>name</code> 和 <code>path</code> 均基于 <code>label</code> 生成，确保唯一性。</li></ul><h3 id="全局路由拦截-guard" tabindex="-1">全局路由拦截 (Guard) <a class="header-anchor" href="#全局路由拦截-guard" aria-label="Permalink to &quot;全局路由拦截 (Guard)&quot;">​</a></h3><p><code>router.beforeEach</code> 承担了“守门员”的角色，处理了复杂的初始化逻辑：</p><p><strong>阶段一：状态恢复</strong></p><ul><li><strong>用户恢复</strong>：如果状态树中没有 UserID，尝试从本地存储读取 Token 恢复登录态。</li><li><strong>菜单恢复</strong>：如果状态树中没有菜单数据，尝试从 IndexedDB (<code>TuiDB</code>) 中读取缓存菜单。</li></ul><p><strong>阶段二：动态加载</strong></p><ul><li><strong>初始化检查</strong>：检查 <code>$ARouterInited</code> 标记。</li><li><strong>执行加载</strong>：如果未初始化，调用 <code>routerPackag($AMenu.value)</code> 执行路由挂载。</li><li><strong>状态翻转</strong>：挂载完成后，将 <code>$ADMIN.value.routerInited</code> 设为 <code>true</code>，并重新触发路由跳转（<code>next({ ...to })</code>）以确保新路由生效。</li></ul><p><strong>阶段三：业务处理</strong></p><ul><li><strong>Tab 管理</strong>：如果目标路由有效且设置了 <code>label</code>，会自动调用 <code>tabAdd(to)</code> 将其加入顶部页签栏。</li><li><strong>缓存管理</strong>：如果 <code>meta.keepAlive</code> 为真，会自动将其 <code>name</code> 加入 <code>$AKeepAlive</code> 列表。</li><li><strong>鉴权失败</strong>：如果上述检查均未通过（无 Token、无 ID），则强制重定向至 <code>/login</code>。</li></ul><h2 id="后端数据结构规范" tabindex="-1">后端数据结构规范 <a class="header-anchor" href="#后端数据结构规范" aria-label="Permalink to &quot;后端数据结构规范&quot;">​</a></h2><p>为了配合动态路由，后端返回的菜单数据（或本地 Mock 数据）应符合以下 JSON 结构：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;label&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dashboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 核心字段：对应 register.js 中的键名</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;仪表盘&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 页面标题</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;icon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ti-dashboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 菜单图标</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;isParent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否为父级菜单目录</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;keepAlive&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否开启页面缓存</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;hideInMenu&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否在侧边栏隐藏</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;hideInTab&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否在 Tab 栏隐藏</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;parentId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;root&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 父节点 ID</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><p><strong>Q: 为什么刷新页面后显示 404？</strong><strong>A:</strong> 通常是因为动态路由尚未加载完成。TechUI 的 <code>beforeEach</code> 逻辑中处理了这种情况：在刷新时，它会先从 IndexedDB 恢复菜单并重新注册路由，然后再执行跳转。如果出现 404，请检查 IndexedDB 是否成功写入了 <code>menus</code> 数据。</p><p><strong>Q: 新增页面如何配置？</strong><strong>A:</strong> 需要两步：</p><ol><li>在前端 <code>register.js</code> 中引入 <code>.vue</code> 文件并导出。</li><li>在后端（或 Mock 数据）中添加对应的菜单项，确保 <code>label</code> 与 <code>register.js</code> 中的键名一致。</li></ol>`,29)])])}const c=i(e,[["render",l]]);export{E as __pageData,c as default};
